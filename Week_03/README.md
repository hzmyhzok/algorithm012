学习笔记
---

105.从前序与中序遍历序列构造二叉树<br>
由于前序遍历是先访问根节点，再分别访问左子树和右子树，所以一颗树的前序遍历列表中第一个元素即为整棵树的根节点。中序遍历是按照左子树，根节点，右子树的顺序来访问，所以整棵树的根节点必定在其所有左边的子孙的后面，同时在其所有右边的子孙的前面，所以我们通过前序遍历中找到的根节点，可以通过中序遍历确定根节点的左右子树分别是哪些元素。再对当前根节点的左右子树进行递归即可达到目标。

236.二叉树的最近公共祖先<br>
如果某root节点是p和q的最近公共祖先，则要么p和q其中一个是另一个的祖先，要么p和q分别在其左右子树中（否则若p和q均在其左子树中，则该节点的左儿子必定是p和q的公共祖先，均在右子树中亦然）。所以当我们找到某节点，p和q分别在其左右子树中时，即找到了最近公共祖先。算法的边界条件为：根节点为null或者p和q其中之一是根节点，此时算法中止并返回根节点。当某节点已经是叶子节点时，算法也将中止并返回null。我们将递归左子树的返回值计为left，右子树计为right，如果left和right均为null，说明该根节点的左右子树中都没有p和q，于是一路向上返回null；当其中一个子树不为null并且另一个时null时，说明不为null的那一侧子树中有p和q中的至少一个，这时分两种情况，第一种是p和q中的一个在该子树中，这时候应该一路向上返回找到的p或者q，第二种是p和q都在该侧子树中，则返回的已经是最近公共祖先节点（即为p和q中更加父辈的那一个节点）；当两侧子树都不是null时，说明p和q分别在两侧子树中，这时候返回root，该root即为最近公共祖先。
